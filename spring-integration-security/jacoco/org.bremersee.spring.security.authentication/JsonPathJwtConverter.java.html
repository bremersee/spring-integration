<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonPathJwtConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Spring Integration Security</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.spring.security.authentication</a> &gt; <span class="el_source">JsonPathJwtConverter.java</span></div><h1>JsonPathJwtConverter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.spring.security.authentication;

import static org.springframework.util.ObjectUtils.isEmpty;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import lombok.AccessLevel;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;

/**
 * The json path jwt converter.
 *
 * @author Christian Bremer
 */
@Getter(AccessLevel.PROTECTED)
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class JsonPathJwtConverter
    extends AuthenticationConverter&lt;Jwt, AbstractAuthenticationToken&gt; {

  /**
   * The json path to the username.
   */
  private final String nameJsonPath;

  /**
   * The json path to the first name.
   */
  private final String firstNameJsonPath;

  /**
   * The json path to the last name.
   */
  private final String lastNameJsonPath;

  /**
   * The json path to the email.
   */
  private final String emailJsonPath;

  /**
   * The json path to the roles.
   */
  private final String rolesJsonPath;

  /**
   * Specifies whether the roles are represented as a json array or as a list separated by
   * {@link #getRolesValueSeparator()}.
   */
  private final boolean rolesValueList;

  /**
   * The roles separator to use if {@link #isRolesValueList()} is set to {@code false}.
   */
  private final String rolesValueSeparator;

  /**
   * Instantiates a new Json path jwt converter.
   *
   * @param nameJsonPath the name json path
   * @param firstNameJsonPath the first name json path
   * @param lastNameJsonPath the last name json path
   * @param emailJsonPath the email json path
   * @param rolesJsonPath the roles json path
   * @param rolesValueList the roles value list
   * @param rolesValueSeparator the roles value separator
   * @param defaultRoles the default roles
   * @param roleMapping the role mapping
   * @param rolePrefix the role prefix
   * @param roleCaseTransformation the role case transformation
   * @param roleStringReplacements the role string replacements
   */
  @Builder(toBuilder = true)
  public JsonPathJwtConverter(
      String nameJsonPath,
      String firstNameJsonPath,
      String lastNameJsonPath,
      String emailJsonPath,
      String rolesJsonPath,
      boolean rolesValueList,
      String rolesValueSeparator,
      List&lt;String&gt; defaultRoles,
      Map&lt;String, String&gt; roleMapping,
      String rolePrefix,
      CaseTransformation roleCaseTransformation,
      Map&lt;String, String&gt; roleStringReplacements) {

<span class="fc" id="L119">    super(defaultRoles, roleMapping, rolePrefix, roleCaseTransformation, roleStringReplacements);</span>
<span class="fc" id="L120">    this.nameJsonPath = nameJsonPath;</span>
<span class="fc" id="L121">    this.firstNameJsonPath = firstNameJsonPath;</span>
<span class="fc" id="L122">    this.lastNameJsonPath = lastNameJsonPath;</span>
<span class="fc" id="L123">    this.emailJsonPath = emailJsonPath;</span>
<span class="fc" id="L124">    this.rolesJsonPath = rolesJsonPath;</span>
<span class="fc" id="L125">    this.rolesValueList = rolesValueList;</span>
<span class="fc" id="L126">    this.rolesValueSeparator = rolesValueSeparator;</span>
<span class="fc" id="L127">  }</span>

  @NonNull
  @Override
  public NormalizedJwtAuthenticationToken convert(@NonNull Jwt source) {
<span class="fc" id="L132">    JsonPathJwtParser parser = new JsonPathJwtParser(source);</span>
<span class="fc" id="L133">    return new NormalizedJwtAuthenticationToken(</span>
        source,
<span class="fc" id="L135">        getGrantedAuthorities(parser),</span>
<span class="fc" id="L136">        getUsername(source, parser),</span>
<span class="fc" id="L137">        getFirstName(parser),</span>
<span class="fc" id="L138">        getLastName(parser),</span>
<span class="fc" id="L139">        getEmail(parser));</span>
  }

  /**
   * Gets granted authorities.
   *
   * @param parser the parser
   * @return the granted authorities
   */
  protected Set&lt;GrantedAuthority&gt; getGrantedAuthorities(JsonPathJwtParser parser) {
<span class="fc bfc" id="L149" title="All 2 branches covered.">    Set&lt;String&gt; authorities = isRolesValueList()</span>
<span class="fc" id="L150">        ? getAuthoritiesFromList(parser)</span>
<span class="fc" id="L151">        : getAuthoritiesFromValue(parser);</span>
<span class="fc" id="L152">    return normalize(authorities);</span>
  }

  /**
   * Gets authorities from list.
   *
   * @param parser the parser
   * @return the authorities from list
   */
  protected Set&lt;String&gt; getAuthoritiesFromList(JsonPathJwtParser parser) {
    //noinspection unchecked
<span class="fc" id="L163">    return Stream.ofNullable(getRolesJsonPath())</span>
<span class="fc" id="L164">        .map(path -&gt; parser.read(path, List.class))</span>
<span class="fc" id="L165">        .filter(Objects::nonNull)</span>
<span class="fc" id="L166">        .map(list -&gt; (List&lt;String&gt;) list)</span>
<span class="fc" id="L167">        .flatMap(Collection::stream)</span>
<span class="fc" id="L168">        .collect(Collectors.toSet());</span>
  }

  /**
   * Gets authorities from value.
   *
   * @param parser the parser
   * @return the authorities from value
   */
  protected Set&lt;String&gt; getAuthoritiesFromValue(JsonPathJwtParser parser) {
<span class="fc" id="L178">    return Stream.ofNullable(getRolesJsonPath())</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        .filter(path -&gt; !isEmpty(getRolesValueSeparator()))</span>
<span class="fc" id="L180">        .map(path -&gt; parser.read(path, String.class))</span>
<span class="fc" id="L181">        .filter(Objects::nonNull)</span>
<span class="fc" id="L182">        .map(value -&gt; value.split(Pattern.quote(getRolesValueSeparator())))</span>
<span class="fc" id="L183">        .flatMap(Arrays::stream)</span>
<span class="fc" id="L184">        .map(String::valueOf)</span>
<span class="fc" id="L185">        .collect(Collectors.toSet());</span>
  }

  /**
   * Gets username.
   *
   * @param source the source
   * @param parser the parser
   * @return the username
   */
  protected String getUsername(Jwt source, JsonPathJwtParser parser) {
<span class="fc" id="L196">    return Optional.ofNullable(getNameJsonPath())</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        .filter(jsonPath -&gt; !jsonPath.isBlank())</span>
<span class="fc" id="L198">        .map(jsonPath -&gt; parser.read(jsonPath, String.class))</span>
<span class="fc" id="L199">        .orElseGet(source::getSubject);</span>
  }

  /**
   * Gets first name.
   *
   * @param parser the parser
   * @return the first name
   */
  protected String getFirstName(JsonPathJwtParser parser) {
<span class="fc" id="L209">    return parser.read(getFirstNameJsonPath(), String.class);</span>
  }

  /**
   * Gets last name.
   *
   * @param parser the parser
   * @return the last name
   */
  protected String getLastName(JsonPathJwtParser parser) {
<span class="fc" id="L219">    return parser.read(getLastNameJsonPath(), String.class);</span>
  }

  /**
   * Gets email.
   *
   * @param parser the parser
   * @return the email
   */
  protected String getEmail(JsonPathJwtParser parser) {
<span class="fc" id="L229">    return parser.read(getEmailJsonPath(), String.class);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>