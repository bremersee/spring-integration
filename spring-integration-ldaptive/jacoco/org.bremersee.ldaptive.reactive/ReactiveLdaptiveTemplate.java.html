<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReactiveLdaptiveTemplate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Spring Integration Ldaptive</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.ldaptive.reactive</a> &gt; <span class="el_source">ReactiveLdaptiveTemplate.java</span></div><h1>ReactiveLdaptiveTemplate.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.ldaptive.reactive;

import static org.ldaptive.handler.ResultPredicate.NOT_SUCCESS;

import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;
import lombok.extern.slf4j.Slf4j;
import org.bremersee.exception.ServiceException;
import org.bremersee.ldaptive.DefaultLdaptiveErrorHandler;
import org.bremersee.ldaptive.LdaptiveEntryMapper;
import org.bremersee.ldaptive.LdaptiveErrorHandler;
import org.bremersee.ldaptive.LdaptiveTemplate;
import org.ldaptive.AddOperation;
import org.ldaptive.AddRequest;
import org.ldaptive.AttributeModification;
import org.ldaptive.BindRequest;
import org.ldaptive.CompareOperation;
import org.ldaptive.CompareRequest;
import org.ldaptive.ConnectionFactory;
import org.ldaptive.DeleteOperation;
import org.ldaptive.DeleteRequest;
import org.ldaptive.LdapAttribute;
import org.ldaptive.LdapEntry;
import org.ldaptive.LdapException;
import org.ldaptive.ModifyDnOperation;
import org.ldaptive.ModifyDnRequest;
import org.ldaptive.ModifyOperation;
import org.ldaptive.ModifyRequest;
import org.ldaptive.Result;
import org.ldaptive.ResultCode;
import org.ldaptive.SearchOperation;
import org.ldaptive.SearchRequest;
import org.ldaptive.extended.ExtendedOperation;
import org.ldaptive.extended.ExtendedRequest;
import org.ldaptive.extended.ExtendedResponse;
import org.ldaptive.handler.ResultHandler;
import org.ldaptive.handler.ResultPredicate;
import reactor.core.publisher.Flux;
import reactor.core.publisher.FluxSink;
import reactor.core.publisher.Mono;

/**
 * The reactive ldaptive template.
 *
 * @author Christian Bremer
 */
<span class="fc" id="L64">@Slf4j</span>
public class ReactiveLdaptiveTemplate implements ReactiveLdaptiveOperations, Cloneable {

<span class="pc bpc" id="L67" title="1 of 2 branches missed.">  private static final ResultPredicate NOT_COMPARE_RESULT = result -&gt; !result.isSuccess()</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">      &amp;&amp; result.getResultCode() != ResultCode.COMPARE_TRUE</span>
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">      &amp;&amp; result.getResultCode() != ResultCode.COMPARE_FALSE;</span>

<span class="fc bfc" id="L71" title="All 2 branches covered.">  private static final ResultPredicate NOT_DELETE_RESULT = result -&gt; !result.isSuccess()</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">      &amp;&amp; result.getResultCode() != ResultCode.NO_SUCH_OBJECT;</span>

<span class="fc" id="L74">  private static final ResultPredicate NOT_FIND_RESULT = NOT_DELETE_RESULT;</span>

  private final ConnectionFactory connectionFactory;

<span class="fc" id="L78">  private LdaptiveErrorHandler errorHandler = new DefaultLdaptiveErrorHandler();</span>

  /**
   * Instantiates a new Reactive ldaptive template.
   *
   * @param connectionFactory the connection factory
   */
<span class="fc" id="L85">  public ReactiveLdaptiveTemplate(ConnectionFactory connectionFactory) {</span>
<span class="fc" id="L86">    this.connectionFactory = connectionFactory;</span>
<span class="fc" id="L87">  }</span>

  @Override
  public ConnectionFactory getConnectionFactory() {
<span class="fc" id="L91">    return connectionFactory;</span>
  }

  /**
   * Sets error handler.
   *
   * @param errorHandler the error handler
   */
  public void setErrorHandler(LdaptiveErrorHandler errorHandler) {
<span class="fc bfc" id="L100" title="All 2 branches covered.">    if (errorHandler != null) {</span>
<span class="fc" id="L101">      this.errorHandler = errorHandler;</span>
    }
<span class="fc" id="L103">  }</span>

  /**
   * Returns a new instance of this ldaptive template with the same connection factory and error
   * handler.
   *
   * @return a new instance of this ldaptive template
   */
  @SuppressWarnings(&quot;MethodDoesntCallSuperMethod&quot;)
  @Override
  public ReactiveLdaptiveTemplate clone() {
<span class="fc" id="L114">    return clone(null);</span>
  }

  /**
   * Returns a new instance of this ldaptive template with the same connection factory and the given
   * error handler.
   *
   * @param errorHandler the new error handler
   * @return the new instance of the ldaptive template
   */
  public ReactiveLdaptiveTemplate clone(final LdaptiveErrorHandler errorHandler) {
<span class="fc" id="L125">    final ReactiveLdaptiveTemplate template = new ReactiveLdaptiveTemplate(connectionFactory);</span>
<span class="fc" id="L126">    template.setErrorHandler(errorHandler);</span>
<span class="fc" id="L127">    return template;</span>
  }

  @Override
  public Mono&lt;Result&gt; add(AddRequest addRequest) {
<span class="fc" id="L132">    CompletableFuture&lt;Result&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L134">      AddOperation.builder()</span>
<span class="fc" id="L135">          .factory(connectionFactory)</span>
<span class="fc" id="L136">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_SUCCESS, errorHandler, r -&gt; r))</span>
<span class="fc" id="L137">          .onException(</span>
<span class="nc" id="L138">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L139">          .build()</span>
<span class="fc" id="L140">          .send(addRequest);</span>

<span class="nc" id="L142">    } catch (LdapException e) {</span>
<span class="nc" id="L143">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L144">    }</span>
<span class="fc" id="L145">    return Mono.fromFuture(future);</span>
  }

  private &lt;T&gt; Mono&lt;T&gt; add(T domainObject, LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="fc" id="L149">    String[] objectClasses = entryMapper.getObjectClasses();</span>
<span class="pc bpc" id="L150" title="2 of 4 branches missed.">    if (objectClasses == null || objectClasses.length == 0) {</span>
<span class="nc" id="L151">      final ServiceException se = ServiceException.internalServerError(</span>
          &quot;Object classes must be specified to save a new ldap entry.&quot;,
          &quot;org.bremersee:ldaptive-integration:d7aa5699-fd2e-45df-a863-97960e8095b8&quot;);
<span class="nc" id="L154">      log.error(&quot;Saving domain object failed.&quot;, se);</span>
<span class="nc" id="L155">      throw se;</span>
    }
<span class="fc" id="L157">    String dn = entryMapper.mapDn(domainObject);</span>
<span class="fc" id="L158">    LdapEntry entry = new LdapEntry();</span>
<span class="fc" id="L159">    entryMapper.map(domainObject, entry);</span>
<span class="fc" id="L160">    entry.setDn(dn);</span>
<span class="fc" id="L161">    entry.addAttributes(new LdapAttribute(&quot;objectclass&quot;, objectClasses));</span>
<span class="fc" id="L162">    return add(new AddRequest(dn, entry.getAttributes()))</span>
<span class="fc" id="L163">        .then(Mono.just(Objects.requireNonNull(entryMapper.map(entry))));</span>
  }

  @Override
  public Mono&lt;Boolean&gt; bind(BindRequest bindRequest) {
    // Bind requests are synchronous
<span class="fc" id="L169">    LdaptiveTemplate template = new LdaptiveTemplate(getConnectionFactory());</span>
<span class="fc" id="L170">    template.setErrorHandler(errorHandler);</span>
<span class="fc" id="L171">    return Mono.just(template.bind(bindRequest));</span>
  }

  @Override
  public Mono&lt;Boolean&gt; compare(CompareRequest compareRequest) {
<span class="fc" id="L176">    CompletableFuture&lt;Boolean&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L178">      CompareOperation.builder()</span>
<span class="fc" id="L179">          .factory(connectionFactory)</span>
<span class="fc" id="L180">          .onCompare(</span>
<span class="fc" id="L181">              future::complete) // this will be only called, if the result is COMPARE_TRUE or COMPARE_FALSE</span>
<span class="fc" id="L182">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_COMPARE_RESULT, errorHandler,</span>
              Result::isSuccess))
<span class="fc" id="L184">          .onException(</span>
<span class="nc" id="L185">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L186">          .build()</span>
<span class="fc" id="L187">          .send(compareRequest);</span>

<span class="nc" id="L189">    } catch (LdapException e) {</span>
<span class="nc" id="L190">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L191">    }</span>
<span class="fc" id="L192">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Mono&lt;Result&gt; delete(DeleteRequest deleteRequest) {
<span class="fc" id="L197">    CompletableFuture&lt;Result&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L199">      DeleteOperation.builder()</span>
<span class="fc" id="L200">          .factory(connectionFactory)</span>
<span class="fc" id="L201">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_DELETE_RESULT, errorHandler, r -&gt; r))</span>
<span class="fc" id="L202">          .onException(</span>
<span class="nc" id="L203">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L204">          .build()</span>
<span class="fc" id="L205">          .send(deleteRequest)</span>
<span class="fc" id="L206">          .await();</span>

<span class="nc" id="L208">    } catch (LdapException e) {</span>
<span class="nc" id="L209">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L210">    }</span>
<span class="fc" id="L211">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Mono&lt;ExtendedResponse&gt; executeExtension(ExtendedRequest request) {

<span class="fc" id="L217">    CompletableFuture&lt;ExtendedResponse&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L219">      ExtendedOperation.builder()</span>
<span class="fc" id="L220">          .factory(connectionFactory)</span>
<span class="fc" id="L221">          .onExtended((name, value) -&gt; future.complete(ExtendedResponse.builder()</span>
<span class="fc" id="L222">              .responseName(name)</span>
<span class="fc" id="L223">              .responseValue(value)</span>
<span class="fc" id="L224">              .resultCode(ResultCode.SUCCESS)</span>
<span class="fc" id="L225">              .build()))</span>
<span class="fc" id="L226">          .onResult(new FutureAwareResultHandler&lt;&gt;(</span>
              future,
              NOT_SUCCESS,
              errorHandler,
<span class="nc" id="L230">              r -&gt; ExtendedResponse.builder().resultCode(r.getResultCode()).build()))</span>
<span class="fc" id="L231">          .onException(</span>
<span class="nc" id="L232">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L233">          .build()</span>
<span class="fc" id="L234">          .send(request);</span>

<span class="nc" id="L236">    } catch (LdapException e) {</span>
<span class="nc" id="L237">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L238">    }</span>
<span class="fc" id="L239">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Mono&lt;Result&gt; modify(ModifyRequest modifyRequest) {
<span class="fc" id="L244">    CompletableFuture&lt;Result&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L246">      ModifyOperation.builder()</span>
<span class="fc" id="L247">          .factory(connectionFactory)</span>
<span class="fc" id="L248">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_SUCCESS, errorHandler, r -&gt; r))</span>
<span class="fc" id="L249">          .onException(</span>
<span class="nc" id="L250">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L251">          .build()</span>
<span class="fc" id="L252">          .send(modifyRequest);</span>

<span class="nc" id="L254">    } catch (LdapException e) {</span>
<span class="nc" id="L255">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L256">    }</span>
<span class="fc" id="L257">    return Mono.fromFuture(future);</span>
  }

  private &lt;T&gt; Mono&lt;T&gt; modify(T domainObject, LdapEntry entry, LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="fc" id="L261">    String dn = entryMapper.mapDn(domainObject);</span>
<span class="fc" id="L262">    AttributeModification[] modifications = entryMapper.mapAndComputeModifications(domainObject,</span>
        entry);
<span class="fc" id="L264">    return modify(new ModifyRequest(dn, modifications))</span>
<span class="fc" id="L265">        .then(Mono.just(Objects.requireNonNull(entryMapper.map(entry))));</span>
  }

  @Override
  public Mono&lt;Result&gt; modifyDn(ModifyDnRequest modifyDnRequest) {
<span class="fc" id="L270">    CompletableFuture&lt;Result&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L272">      ModifyDnOperation.builder()</span>
<span class="fc" id="L273">          .factory(connectionFactory)</span>
<span class="fc" id="L274">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_SUCCESS, errorHandler, r -&gt; r))</span>
<span class="fc" id="L275">          .onException(</span>
<span class="nc" id="L276">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L277">          .build()</span>
<span class="fc" id="L278">          .send(modifyDnRequest);</span>

<span class="nc" id="L280">    } catch (LdapException e) {</span>
<span class="nc" id="L281">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L282">    }</span>
<span class="fc" id="L283">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Mono&lt;LdapEntry&gt; findOne(SearchRequest searchRequest) {
<span class="fc" id="L288">    CompletableFuture&lt;LdapEntry&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L290">      SearchOperation.builder()</span>
<span class="fc" id="L291">          .factory(connectionFactory)</span>
<span class="fc" id="L292">          .onEntry(ldapEntry -&gt; {</span>
<span class="fc" id="L293">            future.complete(ldapEntry);</span>
<span class="fc" id="L294">            return ldapEntry;</span>
          })
<span class="fc" id="L296">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_FIND_RESULT, errorHandler, null))</span>
<span class="pc" id="L297">          .onException(ldapException -&gt; future.obtrudeException(errorHandler.map(ldapException)))</span>
<span class="fc" id="L298">          .build()</span>
<span class="fc" id="L299">          .send(searchRequest);</span>

<span class="nc" id="L301">    } catch (LdapException e) {</span>
<span class="nc" id="L302">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L303">    }</span>
<span class="fc" id="L304">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Flux&lt;LdapEntry&gt; findAll(SearchRequest searchRequest) {
<span class="fc" id="L309">    return Flux.create((FluxSink&lt;LdapEntry&gt; fluxSink) -&gt; {</span>
      try {
<span class="fc" id="L311">        SearchOperation.builder()</span>
<span class="fc" id="L312">            .factory(connectionFactory)</span>
<span class="fc" id="L313">            .onEntry(ldapEntry -&gt; {</span>
<span class="fc" id="L314">              fluxSink.next(ldapEntry);</span>
<span class="fc" id="L315">              return ldapEntry;</span>
            })
<span class="fc" id="L317">            .onResult(new FluxSinkAwareResultHandler&lt;&gt;(fluxSink, NOT_FIND_RESULT, errorHandler))</span>
<span class="pc" id="L318">            .onException(ldapException -&gt; fluxSink.error(errorHandler.map(ldapException)))</span>
<span class="fc" id="L319">            .build()</span>
<span class="fc" id="L320">            .send(searchRequest);</span>

<span class="nc" id="L322">      } catch (LdapException e) {</span>
<span class="nc" id="L323">        fluxSink.error(errorHandler.map(e));</span>
<span class="fc" id="L324">      }</span>
<span class="fc" id="L325">    });</span>
  }

  @Override
  public &lt;T&gt; Mono&lt;T&gt; save(T domainObject, LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="fc" id="L330">    return findOne(SearchRequest.objectScopeSearchRequest(entryMapper.mapDn(domainObject)))</span>
<span class="fc" id="L331">        .flatMap(entry -&gt; modify(domainObject, entry, entryMapper))</span>
<span class="fc" id="L332">        .switchIfEmpty(add(domainObject, entryMapper));</span>
  }

  private static class FutureAwareResultHandler&lt;T&gt; implements ResultHandler {

    private final CompletableFuture&lt;T&gt; future;

    private final ResultPredicate throwErrorPredicate;

    private final LdaptiveErrorHandler errorHandler;

    private final Function&lt;Result, T&gt; resultValueFn;

    /**
     * Instantiates a new Future aware result handler.
     *
     * @param future the future
     * @param throwErrorPredicate the throw error predicate
     * @param errorHandler the error handler
     * @param resultValueFn the result value fn
     */
    public FutureAwareResultHandler(
        CompletableFuture&lt;T&gt; future,
        ResultPredicate throwErrorPredicate,
        LdaptiveErrorHandler errorHandler,
<span class="fc" id="L357">        Function&lt;Result, T&gt; resultValueFn) {</span>
<span class="fc" id="L358">      this.throwErrorPredicate = throwErrorPredicate;</span>
<span class="fc" id="L359">      this.errorHandler = errorHandler;</span>
<span class="fc" id="L360">      this.future = future;</span>
<span class="fc" id="L361">      this.resultValueFn = resultValueFn;</span>
<span class="fc" id="L362">    }</span>

    @Override
    public void accept(Result result) {
<span class="fc bfc" id="L366" title="All 2 branches covered.">      if (!future.isDone()) {</span>
<span class="pc bpc" id="L367" title="1 of 4 branches missed.">        if (throwErrorPredicate != null &amp;&amp; throwErrorPredicate.test(result)) {</span>
<span class="fc" id="L368">          future.completeExceptionally(errorHandler.map(new LdapException(result)));</span>
        } else {
<span class="fc bfc" id="L370" title="All 2 branches covered.">          future.complete(resultValueFn != null ? resultValueFn.apply(result) : null);</span>
        }
      }
<span class="fc" id="L373">    }</span>
  }

  private static class FluxSinkAwareResultHandler&lt;T&gt; implements ResultHandler {

    private final FluxSink&lt;T&gt; fluxSink;

    private final ResultPredicate throwErrorPredicate;

    private final LdaptiveErrorHandler errorHandler;

    /**
     * Instantiates a new Flux sink aware result handler.
     *
     * @param fluxSink the flux sink
     * @param throwErrorPredicate the throw error predicate
     * @param errorHandler the error handler
     */
    public FluxSinkAwareResultHandler(
        FluxSink&lt;T&gt; fluxSink,
        ResultPredicate throwErrorPredicate,
<span class="fc" id="L394">        LdaptiveErrorHandler errorHandler) {</span>
<span class="fc" id="L395">      this.throwErrorPredicate = throwErrorPredicate;</span>
<span class="fc" id="L396">      this.errorHandler = errorHandler;</span>
<span class="fc" id="L397">      this.fluxSink = fluxSink;</span>
<span class="fc" id="L398">    }</span>

    @Override
    public void accept(Result result) {
<span class="pc bpc" id="L402" title="2 of 4 branches missed.">      if (throwErrorPredicate != null &amp;&amp; throwErrorPredicate.test(result)) {</span>
<span class="nc" id="L403">        fluxSink.error(errorHandler.map(new LdapException(result)));</span>
      } else {
<span class="fc" id="L405">        fluxSink.complete();</span>
      }
<span class="fc" id="L407">    }</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>